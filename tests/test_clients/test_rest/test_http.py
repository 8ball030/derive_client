from decimal import Decimal

import pytest
from eth_account import Account

from derive_client._clients.rest.http.client import HTTPClient
from derive_client.constants import INT64_MAX
from derive_client.data.generated.models import (
    CurrencyDetailedResponseSchema,
    Direction,
    InstrumentPublicResponseSchema,
    InstrumentType,
    PrivateCancelByInstrumentResultSchema,
    PrivateCancelByLabelResultSchema,
    PrivateCancelByNonceResultSchema,
    PrivateCancelResultSchema,
    PrivateCreateSubaccountResultSchema,
    PrivateDepositResultSchema,
    PrivateEditSessionKeyResultSchema,
    PrivateGetAccountResultSchema,
    PrivateGetOpenOrdersResultSchema,
    PrivateGetOrderResultSchema,
    PrivateGetOrdersParamsSchema,
    PrivateGetOrdersResponseSchema,
    PrivateGetOrdersResultSchema,
    PrivateGetSubaccountResultSchema,
    PrivateGetSubaccountsParamsSchema,
    PrivateGetSubaccountsResponseSchema,
    PrivateGetSubaccountsResultSchema,
    PrivateOrderResultSchema,
    PrivateRegisterScopedSessionKeyResultSchema,
    PrivateReplaceResultSchema,
    PrivateSessionKeysResultSchema,
    PrivateWithdrawResultSchema,
    PublicGetAllInstrumentsResultSchema,
    PublicGetCurrencyResultSchema,
    PublicGetInstrumentResultSchema,
    PublicGetTickerParamsSchema,
    PublicGetTickerResponseSchema,
    PublicGetTickerResultSchema,
    PublicGetTransactionResultSchema,
    Result,
    Scope,
)
from derive_client.data_types import Environment

OWNER_TEST_WALLET = "0xA419f70C696a4b449a4A24F92e955D91482d44e9"
ADMIN_TEST_WALLET = "0x8772185a1516f0d61fC1c2524926BfC69F95d698"
SESSION_KEY_PRIVATE_KEY = "0x2ae8be44db8a590d20bffbe3b6872df9b569147d3bf6801a35a28281a4816bbd"


@pytest.fixture(scope="session")
def client_owner_wallet():
    """
    Client connected to a wallet where the session key is the owner.
    Full authority over the wallet is available, allowing owner-level operations.
    """
    subaccount_id = 137626
    client = HTTPClient(
        wallet=OWNER_TEST_WALLET,
        session_key=SESSION_KEY_PRIVATE_KEY,
        subaccount_id=subaccount_id,
        env=Environment.TEST,
    )
    client.connect()
    yield client
    client.orders.cancel_all()


@pytest.fixture(scope="session")
def client_admin_wallet():
    """
    Client connected to a wallet where the session key is registered as admin.
    This wallet is NOT owned by the session key, so only admin-level operations are allowed.
    """
    subaccount_id = 31049
    client = HTTPClient(
        wallet=ADMIN_TEST_WALLET,
        session_key=SESSION_KEY_PRIVATE_KEY,
        subaccount_id=subaccount_id,
        env=Environment.TEST,
    )
    client.connect()
    yield client
    client.orders.cancel_all()


# Autogenerated API
def test_public_get_ticker(client_admin_wallet):
    instrument_name = "ETH-PERP"
    params = PublicGetTickerParamsSchema(instrument_name=instrument_name)
    response = client_admin_wallet._public_api.get_ticker(params=params)
    assert isinstance(response, PublicGetTickerResponseSchema)


def test_get_private_get_subaccounts(client_admin_wallet):
    wallet = client_admin_wallet.wallet
    params = PrivateGetSubaccountsParamsSchema(wallet=wallet)
    response = client_admin_wallet._private_api.get_subaccounts(params=params)
    assert isinstance(response, PrivateGetSubaccountsResponseSchema)


def test_get_private_get_orders(client_admin_wallet):
    subaccount_id = client_admin_wallet.active_subaccount.id
    params = PrivateGetOrdersParamsSchema(subaccount_id=subaccount_id)
    response = client_admin_wallet._private_api.get_orders(params=params)
    assert isinstance(response, PrivateGetOrdersResponseSchema)


# Accounts
@pytest.mark.skip(reason="Disabled to prevent test account clutter.")
def test_account_register_scoped_session_key(client_admin_wallet):
    expiry_sec = INT64_MAX
    account = Account.create()
    public_session_key = account.address
    scoped_session_key = client_admin_wallet.account.register_scoped_session_key(
        expiry_sec=expiry_sec,
        public_session_key=public_session_key,
        scope=Scope.account,
    )
    assert isinstance(scoped_session_key, PrivateRegisterScopedSessionKeyResultSchema)


def test_account_edit_session_key(client_admin_wallet):
    session_keys = client_admin_wallet.account.session_keys()
    public_session_key = session_keys.public_session_keys[0].public_session_key
    session_key = client_admin_wallet.account.edit_session_key(public_session_key=public_session_key)
    assert isinstance(session_key, PrivateEditSessionKeyResultSchema)


def test_account_session_keys(client_admin_wallet):
    session_keys = client_admin_wallet.account.session_keys()
    assert isinstance(session_keys, PrivateSessionKeysResultSchema)


def test_account_get_all_portfolios(client_admin_wallet):
    all_portfolios = client_admin_wallet.account.get_all_portfolios()
    assert isinstance(all_portfolios, list)
    assert all(isinstance(item, PrivateGetSubaccountResultSchema) for item in all_portfolios)


def test_account_get_subaccounts(client_admin_wallet):
    subaccounts = client_admin_wallet.account.get_subaccounts()
    assert isinstance(subaccounts, PrivateGetSubaccountsResultSchema)


def test_account_get(client_admin_wallet):
    account = client_admin_wallet.account.get()
    assert isinstance(account, PrivateGetAccountResultSchema)


@pytest.mark.skip(reason="Disabled to prevent test account clutter.")
def test_account_create_subaccount(client_admin_wallet):
    create_subaccount_result = client_admin_wallet.account.create_subaccount()
    assert isinstance(create_subaccount_result, PrivateCreateSubaccountResultSchema)


# Markets
def test_markets_get_currency(client_admin_wallet):
    currency = "ETH"
    currency = client_admin_wallet.markets.get_currency(currency=currency)
    assert isinstance(currency, PublicGetCurrencyResultSchema)


def test_markets_get_all_currencies(client_admin_wallet):
    currencies = client_admin_wallet.markets.get_all_currencies()
    assert isinstance(currencies, list)
    assert all(isinstance(item, CurrencyDetailedResponseSchema) for item in currencies)


def test_markets_get_instrument(client_admin_wallet):
    instrument_name = "ETH-PERP"
    instrument = client_admin_wallet.markets.get_instrument(instrument_name=instrument_name)
    assert isinstance(instrument, PublicGetInstrumentResultSchema)


def test_markets_get_instruments(client_admin_wallet):
    currency = "ETH"
    expired = False
    instrument_type = InstrumentType.option
    instruments = client_admin_wallet.markets.get_instruments(
        currency=currency,
        expired=expired,
        instrument_type=instrument_type,
    )
    assert isinstance(instruments, list)
    assert all(isinstance(item, InstrumentPublicResponseSchema) for item in instruments)


def test_markets_get_all_instruments(client_admin_wallet):
    expired = False
    instrument_type = InstrumentType.perp
    currency = None
    page = 1
    page_size = 100
    all_instruments = client_admin_wallet.markets.get_all_instruments(
        expired=expired,
        instrument_type=instrument_type,
        currency=currency,
        page=page,
        page_size=page_size,
    )
    assert isinstance(all_instruments, PublicGetAllInstrumentsResultSchema)


def test_markets_get_ticker(client_admin_wallet):
    instrument_name = "ETH-PERP"
    ticker = client_admin_wallet.markets.get_ticker(instrument_name=instrument_name)
    assert isinstance(ticker, PublicGetTickerResultSchema)


def test_markets_get_all_tickers(client_admin_wallet):
    currency = "ETH"
    expired = False
    instrument_type = InstrumentType.perp
    tickers = client_admin_wallet.markets.get_all_tickers(
        currency=currency,
        expired=expired,
        instrument_type=instrument_type,
    )
    assert isinstance(tickers, list)
    assert all(isinstance(item, PublicGetTickerResultSchema) for item in tickers)


# Transactions
def test_transactions_get(client_admin_wallet):
    transaction_id = "f589e847-c7a5-40c4-82d5-2d8cec9c93da"
    transaction = client_admin_wallet.transactions.get(transaction_id=transaction_id)
    assert isinstance(transaction, PublicGetTransactionResultSchema)


def test_transactions_deposit_to_subaccount(client_admin_wallet):
    amount = Decimal("0.10")
    asset_name = "USDC"
    deposit = client_admin_wallet.transactions.deposit_to_subaccount(amount=amount, asset_name=asset_name)
    assert isinstance(deposit, PrivateDepositResultSchema)


def test_transactions_withdraw_from_subaccount(client_admin_wallet):
    amount = Decimal("0.10")
    asset_name = "USDC"
    withdrawal = client_admin_wallet.transactions.withdraw_from_subaccount(amount=amount, asset_name=asset_name)
    assert isinstance(withdrawal, PrivateWithdrawResultSchema)


# Orders
def _create_order(
    client,
    amount=Decimal("0.10"),
    instrument_name: str = "ETH-PERP",
    direction=Direction.buy,
    limit_price=Decimal("200.00"),
) -> PrivateOrderResultSchema:
    max_fee = Decimal("1000")
    label = "test_order"
    order = client.orders.create(
        amount=amount,
        direction=direction,
        instrument_name=instrument_name,
        limit_price=limit_price,
        max_fee=max_fee,
        label=label,
    )
    return order


def test_orders_create(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    assert isinstance(order, PrivateOrderResultSchema)


def test_orders_get(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    order_id = order.order.order_id
    order = client_admin_wallet.orders.get(order_id=order_id)
    assert isinstance(order, PrivateGetOrderResultSchema)


def test_orders_list(client_admin_wallet):
    orders = client_admin_wallet.orders.list()
    assert isinstance(orders, PrivateGetOrdersResultSchema)


def test_orders_list_open(client_admin_wallet):
    open_orders = client_admin_wallet.orders.list_open()
    assert isinstance(open_orders, PrivateGetOpenOrdersResultSchema)


def test_orders_cancel(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    order_id = order.order.order_id
    cancelled = client_admin_wallet.orders.cancel(
        instrument_name=order.order.instrument_name,
        order_id=order_id,
    )
    assert isinstance(cancelled, PrivateCancelResultSchema)


def test_orders_cancel_by_label(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    cancelled_by_label = client_admin_wallet.orders.cancel_by_label(label=order.order.label)
    assert isinstance(cancelled_by_label, PrivateCancelByLabelResultSchema)


def test_orders_cancel_by_nonce(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    cancelled_by_label = client_admin_wallet.orders.cancel_by_nonce(
        instrument_name=order.order.instrument_name,
        nonce=order.order.nonce,
    )
    assert isinstance(cancelled_by_label, PrivateCancelByNonceResultSchema)


def test_orders_cancel_by_instrument(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    cancelled_by_label = client_admin_wallet.orders.cancel_by_instrument(instrument_name=order.order.instrument_name)
    assert isinstance(cancelled_by_label, PrivateCancelByInstrumentResultSchema)


def test_orders_cancel_all(client_admin_wallet):
    cancelled_all = client_admin_wallet.orders.cancel_all()
    assert isinstance(cancelled_all, Result)


def test_orders_replace(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    order_id = order.order.order_id
    replace = client_admin_wallet.orders.replace(
        amount=order.order.amount,
        direction=order.order.direction,
        instrument_name=order.order.instrument_name,
        limit_price=order.order.limit_price,
        max_fee=order.order.max_fee,
        order_id_to_cancel=order_id,
    )
    assert isinstance(replace, PrivateReplaceResultSchema)
