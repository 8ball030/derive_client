import time
from decimal import Decimal

import pytest
from eth_account import Account

from derive_client._clients.rest.http.client import HTTPClient
from derive_client._clients.rest.http.subaccount import Subaccount
from derive_client._clients.utils import PositionTransfer
from derive_client.constants import INT64_MAX
from derive_client.data.generated.models import (
    CurrencyDetailedResponseSchema,
    Direction,
    InstrumentPublicResponseSchema,
    InstrumentType,
    OrderType,
    PositionResponseSchema,
    PrivateCancelByInstrumentResultSchema,
    PrivateCancelByLabelResultSchema,
    PrivateCancelByNonceResultSchema,
    PrivateCancelResultSchema,
    PrivateCreateSubaccountResultSchema,
    PrivateDepositResultSchema,
    PrivateEditSessionKeyResultSchema,
    PrivateGetAccountResultSchema,
    PrivateGetOpenOrdersResultSchema,
    PrivateGetOrderResultSchema,
    PrivateGetOrdersParamsSchema,
    PrivateGetOrdersResponseSchema,
    PrivateGetOrdersResultSchema,
    PrivateGetSubaccountResultSchema,
    PrivateGetSubaccountsParamsSchema,
    PrivateGetSubaccountsResponseSchema,
    PrivateGetSubaccountsResultSchema,
    PrivateOrderResultSchema,
    PrivateRegisterScopedSessionKeyResultSchema,
    PrivateReplaceResultSchema,
    PrivateSessionKeysResultSchema,
    PrivateTransferPositionResultSchema,
    PrivateTransferPositionsResultSchema,
    PrivateWithdrawResultSchema,
    PublicGetAllInstrumentsResultSchema,
    PublicGetCurrencyResultSchema,
    PublicGetInstrumentResultSchema,
    PublicGetTickerParamsSchema,
    PublicGetTickerResponseSchema,
    PublicGetTickerResultSchema,
    PublicGetTransactionResultSchema,
    Result,
    Scope,
    TxStatus,
)
from derive_client.data_types import Environment

OWNER_TEST_WALLET = "0xA419f70C696a4b449a4A24F92e955D91482d44e9"
ADMIN_TEST_WALLET = "0x8772185a1516f0d61fC1c2524926BfC69F95d698"
SESSION_KEY_PRIVATE_KEY = "0x2ae8be44db8a590d20bffbe3b6872df9b569147d3bf6801a35a28281a4816bbd"


@pytest.fixture(autouse=True)
def slow_down_every_test(request):
    time.sleep(1)


@pytest.fixture(scope="session")
def client_owner_wallet():
    """
    Client connected to a wallet where the session key is the owner.
    Full authority over the wallet is available, allowing owner-level operations.
    """
    subaccount_id = 137626
    client = HTTPClient(
        wallet=OWNER_TEST_WALLET,
        session_key=SESSION_KEY_PRIVATE_KEY,
        subaccount_id=subaccount_id,
        env=Environment.TEST,
    )
    client.connect()
    yield client
    client.orders.cancel_all()


@pytest.fixture(scope="session")
def client_admin_wallet():
    """
    Client connected to a wallet where the session key is registered as admin.
    This wallet is NOT owned by the session key, so only admin-level operations are allowed.
    """
    subaccount_id = 31049
    client = HTTPClient(
        wallet=ADMIN_TEST_WALLET,
        session_key=SESSION_KEY_PRIVATE_KEY,
        subaccount_id=subaccount_id,
        env=Environment.TEST,
    )
    client.connect()
    yield client
    client.orders.cancel_all()


# Autogenerated API
def test_public_get_ticker(client_admin_wallet):
    instrument_name = "ETH-PERP"
    params = PublicGetTickerParamsSchema(instrument_name=instrument_name)
    response = client_admin_wallet._public_api.get_ticker(params=params)
    assert isinstance(response, PublicGetTickerResponseSchema)


def test_get_private_get_subaccounts(client_admin_wallet):
    wallet = client_admin_wallet.wallet
    params = PrivateGetSubaccountsParamsSchema(wallet=wallet)
    response = client_admin_wallet._private_api.get_subaccounts(params=params)
    assert isinstance(response, PrivateGetSubaccountsResponseSchema)


def test_get_private_get_orders(client_admin_wallet):
    subaccount_id = client_admin_wallet.active_subaccount.id
    params = PrivateGetOrdersParamsSchema(subaccount_id=subaccount_id)
    response = client_admin_wallet._private_api.get_orders(params=params)
    assert isinstance(response, PrivateGetOrdersResponseSchema)


# Accounts
@pytest.mark.skip(reason="Disabled to prevent test account clutter.")
def test_account_register_scoped_session_key(client_admin_wallet):
    expiry_sec = INT64_MAX
    account = Account.create()
    public_session_key = account.address
    scoped_session_key = client_admin_wallet.account.register_scoped_session_key(
        expiry_sec=expiry_sec,
        public_session_key=public_session_key,
        scope=Scope.account,
    )
    assert isinstance(scoped_session_key, PrivateRegisterScopedSessionKeyResultSchema)


def test_account_edit_session_key(client_admin_wallet):
    session_keys = client_admin_wallet.account.session_keys()
    public_session_key = session_keys.public_session_keys[0].public_session_key
    session_key = client_admin_wallet.account.edit_session_key(public_session_key=public_session_key)
    assert isinstance(session_key, PrivateEditSessionKeyResultSchema)


def test_account_session_keys(client_admin_wallet):
    session_keys = client_admin_wallet.account.session_keys()
    assert isinstance(session_keys, PrivateSessionKeysResultSchema)


def test_account_get_all_portfolios(client_admin_wallet):
    all_portfolios = client_admin_wallet.account.get_all_portfolios()
    assert isinstance(all_portfolios, list)
    assert all(isinstance(item, PrivateGetSubaccountResultSchema) for item in all_portfolios)


def test_account_get_subaccounts(client_admin_wallet):
    subaccounts = client_admin_wallet.account.get_subaccounts()
    assert isinstance(subaccounts, PrivateGetSubaccountsResultSchema)


def test_account_get(client_admin_wallet):
    account = client_admin_wallet.account.get()
    assert isinstance(account, PrivateGetAccountResultSchema)


@pytest.mark.skip(reason="Disabled to prevent test account clutter.")
def test_account_create_subaccount(client_admin_wallet):
    create_subaccount_result = client_admin_wallet.account.create_subaccount()
    assert isinstance(create_subaccount_result, PrivateCreateSubaccountResultSchema)


# Markets
def test_markets_get_currency(client_admin_wallet):
    currency = "ETH"
    currency = client_admin_wallet.markets.get_currency(currency=currency)
    assert isinstance(currency, PublicGetCurrencyResultSchema)


def test_markets_get_all_currencies(client_admin_wallet):
    currencies = client_admin_wallet.markets.get_all_currencies()
    assert isinstance(currencies, list)
    assert all(isinstance(item, CurrencyDetailedResponseSchema) for item in currencies)


def test_markets_get_instrument(client_admin_wallet):
    instrument_name = "ETH-PERP"
    instrument = client_admin_wallet.markets.get_instrument(instrument_name=instrument_name)
    assert isinstance(instrument, PublicGetInstrumentResultSchema)


def test_markets_get_instruments(client_admin_wallet):
    currency = "ETH"
    expired = False
    instrument_type = InstrumentType.option
    instruments = client_admin_wallet.markets.get_instruments(
        currency=currency,
        expired=expired,
        instrument_type=instrument_type,
    )
    assert isinstance(instruments, list)
    assert all(isinstance(item, InstrumentPublicResponseSchema) for item in instruments)


def test_markets_get_all_instruments(client_admin_wallet):
    expired = False
    instrument_type = InstrumentType.perp
    currency = None
    page = 1
    page_size = 100
    all_instruments = client_admin_wallet.markets.get_all_instruments(
        expired=expired,
        instrument_type=instrument_type,
        currency=currency,
        page=page,
        page_size=page_size,
    )
    assert isinstance(all_instruments, PublicGetAllInstrumentsResultSchema)


def test_markets_get_ticker(client_admin_wallet):
    instrument_name = "ETH-PERP"
    ticker = client_admin_wallet.markets.get_ticker(instrument_name=instrument_name)
    assert isinstance(ticker, PublicGetTickerResultSchema)


def test_markets_get_all_tickers(client_admin_wallet):
    currency = "ETH"
    expired = False
    instrument_type = InstrumentType.perp
    tickers = client_admin_wallet.markets.get_all_tickers(
        currency=currency,
        expired=expired,
        instrument_type=instrument_type,
    )
    assert isinstance(tickers, list)
    assert all(isinstance(item, PublicGetTickerResultSchema) for item in tickers)


# Transactions
def test_transactions_get(client_admin_wallet):
    transaction_id = "f589e847-c7a5-40c4-82d5-2d8cec9c93da"
    transaction = client_admin_wallet.transactions.get(transaction_id=transaction_id)
    assert isinstance(transaction, PublicGetTransactionResultSchema)


def test_transactions_deposit_to_subaccount(client_admin_wallet):
    amount = Decimal("0.10")
    asset_name = "USDC"
    deposit = client_admin_wallet.transactions.deposit_to_subaccount(amount=amount, asset_name=asset_name)
    assert isinstance(deposit, PrivateDepositResultSchema)


def test_transactions_withdraw_from_subaccount(client_admin_wallet):
    amount = Decimal("0.10")
    asset_name = "USDC"
    withdrawal = client_admin_wallet.transactions.withdraw_from_subaccount(amount=amount, asset_name=asset_name)
    assert isinstance(withdrawal, PrivateWithdrawResultSchema)


# Orders
def _create_order(
    client,
    amount=Decimal("0.10"),
    instrument_name: str = "ETH-PERP",
    direction=Direction.buy,
    limit_price=Decimal("200.00"),
) -> PrivateOrderResultSchema:
    max_fee = Decimal("1000")
    order_type = OrderType.limit
    label = "test_order"

    order = client.orders.create(
        amount=amount,
        direction=direction,
        instrument_name=instrument_name,
        limit_price=limit_price,
        max_fee=max_fee,
        order_type=order_type,
        label=label,
    )
    return order


def test_orders_create(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    assert isinstance(order, PrivateOrderResultSchema)


def test_orders_get(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    order_id = order.order.order_id
    order = client_admin_wallet.orders.get(order_id=order_id)
    assert isinstance(order, PrivateGetOrderResultSchema)


def test_orders_list(client_admin_wallet):
    orders = client_admin_wallet.orders.list()
    assert isinstance(orders, PrivateGetOrdersResultSchema)


def test_orders_list_open(client_admin_wallet):
    open_orders = client_admin_wallet.orders.list_open()
    assert isinstance(open_orders, PrivateGetOpenOrdersResultSchema)


def test_orders_cancel(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    order_id = order.order.order_id
    cancelled = client_admin_wallet.orders.cancel(
        instrument_name=order.order.instrument_name,
        order_id=order_id,
    )
    assert isinstance(cancelled, PrivateCancelResultSchema)


def test_orders_cancel_by_label(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    cancelled_by_label = client_admin_wallet.orders.cancel_by_label(label=order.order.label)
    assert isinstance(cancelled_by_label, PrivateCancelByLabelResultSchema)


def test_orders_cancel_by_nonce(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    cancelled_by_label = client_admin_wallet.orders.cancel_by_nonce(
        instrument_name=order.order.instrument_name,
        nonce=order.order.nonce,
    )
    assert isinstance(cancelled_by_label, PrivateCancelByNonceResultSchema)


def test_orders_cancel_by_instrument(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    cancelled_by_label = client_admin_wallet.orders.cancel_by_instrument(instrument_name=order.order.instrument_name)
    assert isinstance(cancelled_by_label, PrivateCancelByInstrumentResultSchema)


def test_orders_cancel_all(client_admin_wallet):
    cancelled_all = client_admin_wallet.orders.cancel_all()
    assert isinstance(cancelled_all, Result)


def test_orders_replace(client_admin_wallet):
    order = _create_order(client_admin_wallet)
    order_id = order.order.order_id
    replace = client_admin_wallet.orders.replace(
        amount=order.order.amount,
        direction=order.order.direction,
        instrument_name=order.order.instrument_name,
        limit_price=order.order.limit_price,
        max_fee=order.order.max_fee,
        order_id_to_cancel=order_id,
    )
    assert isinstance(replace, PrivateReplaceResultSchema)


# Positions
def _get_open_positions_for_instrument(subaccount: Subaccount, *instrument_name: str) -> list[PositionResponseSchema]:
    positions = subaccount.positions.list().positions
    return [p for p in positions if p.instrument_name in instrument_name and p.amount != 0]


def _wait_for_tx_settlement(
    client,
    transaction_id: str,
    timeout: int = 10,
    poll_interval: float = 1.0,
):
    start_time = time.time()
    while time.time() - start_time < timeout:
        transaction = client.transactions.get(transaction_id)
        if transaction.status == TxStatus.settled:
            return transaction
        time.sleep(poll_interval)
    raise TimeoutError(f"on transaction settlement: transaction_id={transaction_id} timeout={timeout}s")


def test_position_transfer(client_owner_wallet):
    instrument_name = "ETH-PERP"

    client_owner_wallet.fetch_subaccounts()
    subaccount_a, subaccount_b = client_owner_wallet.cached_subaccounts[:2]

    positions_a = _get_open_positions_for_instrument(subaccount_a, instrument_name)
    positions_b = _get_open_positions_for_instrument(subaccount_b, instrument_name)

    if positions_a and not positions_b:
        source = subaccount_a
        target = subaccount_b
        initial_position = positions_a[0]
    elif positions_b and not positions_a:
        source = subaccount_b
        target = subaccount_a
        initial_position = positions_b[0]
    else:
        raise ValueError(
            f"Expected exactly one subaccount to have {instrument_name} position. ",
            f"Found: subaccount_a={len(positions_a)}, subaccount_b={len(positions_b)}",
        )

    transfer = source.positions.transfer(
        amount=initial_position.amount,  # can be negative
        instrument_name=initial_position.instrument_name,
        to_subaccount=target.id,
    )

    assert isinstance(transfer, PrivateTransferPositionResultSchema)
    assert transfer.taker_trade.transaction_id == transfer.maker_trade.transaction_id

    _transaction = _wait_for_tx_settlement(
        client=client_owner_wallet,
        transaction_id=transfer.taker_trade.transaction_id,
    )

    source_positions = _get_open_positions_for_instrument(source, instrument_name)
    target_positions = _get_open_positions_for_instrument(target, instrument_name)

    assert not source_positions
    assert target_positions


def test_position_transfer_batch(client_owner_wallet):
    instrument_names = ("BTC-PERP", "BTC-20251226-110000-C")

    client_owner_wallet.fetch_subaccounts()
    subaccount_a, subaccount_b = client_owner_wallet.cached_subaccounts[:2]

    positions_a = _get_open_positions_for_instrument(subaccount_a, *instrument_names)
    positions_b = _get_open_positions_for_instrument(subaccount_b, *instrument_names)

    if len(positions_a) == 2 and len(positions_b) != 2:
        source = subaccount_a
        target = subaccount_b
        initial_positions = positions_a
    elif len(positions_b) == 2 and len(positions_a) != 2:
        source = subaccount_b
        target = subaccount_a
        initial_positions = positions_b
    else:
        raise ValueError(
            f"Expected exactly one subaccount to have {instrument_names} positions. ",
            f"Found: subaccount_a={len(positions_a)}, subaccount_b={len(positions_b)}",
        )

    positions = []
    for position in initial_positions:
        position = PositionTransfer(
            amount=position.amount,
            instrument_name=position.instrument_name,
        )
        positions.append(position)

    direction = Direction.buy
    transfer_batch = source.positions.transfer_batch(
        positions=positions,
        direction=direction,
        to_subaccount=target.id,
    )

    assert isinstance(transfer_batch, PrivateTransferPositionsResultSchema)
    assert transfer_batch.maker_quote.rfq_id == transfer_batch.taker_quote.rfq_id

    source_positions = _get_open_positions_for_instrument(source, *instrument_names)
    target_positions = _get_open_positions_for_instrument(target, *instrument_names)

    assert len(source_positions) != 2
    assert len(target_positions) == 2
